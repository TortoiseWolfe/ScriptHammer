#!/usr/bin/env node

/**
 * Auto-detects project information from git remote URL
 * Generates project configuration for build-time use
 */

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

function getGitRemoteUrl() {
  try {
    const url = execSync('git remote get-url origin', {
      encoding: 'utf8',
    }).trim();
    return url;
  } catch (error) {
    console.warn('Warning: Not a git repository or no remote origin set');
    return null;
  }
}

function parseGitUrl(url) {
  if (!url) return null;

  // Handle different Git URL formats
  const patterns = [
    // HTTPS: https://github.com/username/repo.git
    /https?:\/\/github\.com\/([^\/]+)\/([^\/\.]+)(\.git)?$/,
    // SSH: git@github.com:username/repo.git
    /git@github\.com:([^\/]+)\/([^\/\.]+)(\.git)?$/,
    // GitHub CLI: gh:username/repo
    /gh:([^\/]+)\/([^\/]+)$/,
  ];

  for (const pattern of patterns) {
    const match = url.match(pattern);
    if (match) {
      return {
        owner: match[1],
        repo: match[2],
        isGitHub: true,
      };
    }
  }

  // Try generic git URL parsing for other hosts
  const genericPattern =
    /(?:git@|https?:\/\/)([^:\/]+)[:\\/]([^\/]+)\/([^\/\.]+)/;
  const genericMatch = url.match(genericPattern);
  if (genericMatch) {
    return {
      host: genericMatch[1],
      owner: genericMatch[2],
      repo: genericMatch[3],
      isGitHub: genericMatch[1].includes('github'),
    };
  }

  return null;
}

function getProjectInfo() {
  // Check for environment variable overrides first
  if (
    process.env.NEXT_PUBLIC_PROJECT_NAME &&
    process.env.NEXT_PUBLIC_PROJECT_OWNER
  ) {
    return {
      projectName: process.env.NEXT_PUBLIC_PROJECT_NAME,
      projectOwner: process.env.NEXT_PUBLIC_PROJECT_OWNER,
      isGitHub: true,
      source: 'env',
    };
  }

  // Try to detect from git
  const gitUrl = getGitRemoteUrl();
  const gitInfo = parseGitUrl(gitUrl);

  if (gitInfo) {
    return {
      projectName: gitInfo.repo,
      projectOwner: gitInfo.owner,
      projectHost: gitInfo.host || 'github.com',
      isGitHub: gitInfo.isGitHub,
      source: 'git',
      gitUrl: gitUrl,
    };
  }

  // Fallback to defaults
  return {
    projectName: 'ScriptHammer',
    projectOwner: 'TortoiseWolfe',
    projectHost: 'github.com',
    isGitHub: true,
    source: 'default',
  };
}

function generateConfig() {
  const info = getProjectInfo();

  // Determine if we're in GitHub Actions CI/CD
  const isGitHubActions = process.env.GITHUB_ACTIONS === 'true';

  // Check if using custom domain (CNAME file exists)
  const cnameExists = fs.existsSync(
    path.join(__dirname, '..', 'public', 'CNAME')
  );

  // Generate base path for GitHub Pages - ONLY in GitHub Actions CI/CD without custom domain
  const basePath =
    isGitHubActions && info.isGitHub && !cnameExists
      ? `/${info.projectName}`
      : '';

  const config = {
    projectName: info.projectName,
    projectOwner: info.projectOwner,
    projectHost: info.projectHost || 'github.com',
    projectUrl: info.isGitHub
      ? `https://github.com/${info.projectOwner}/${info.projectName}`
      : info.gitUrl || '',
    basePath: basePath,
    isGitHub: info.isGitHub,
    detectionSource: info.source,
    generatedAt: new Date().toISOString(),
  };

  // Write to multiple formats for flexibility
  const configDir = path.join(__dirname, '..', 'src', 'config');

  // Ensure config directory exists
  if (!fs.existsSync(configDir)) {
    fs.mkdirSync(configDir, { recursive: true });
  }

  // Write JSON version
  const jsonPath = path.join(configDir, 'project-detected.json');
  fs.writeFileSync(jsonPath, JSON.stringify(config, null, 2));

  // Write TypeScript module
  const tsContent = `// Auto-generated by detect-project.js
// DO NOT EDIT MANUALLY - This file is regenerated on each build

export const detectedConfig = ${JSON.stringify(config, null, 2)} as const;

export type DetectedConfig = typeof detectedConfig;
`;

  const tsPath = path.join(configDir, 'project-detected.ts');
  fs.writeFileSync(tsPath, tsContent);

  // Write .env.local if it doesn't exist
  const envPath = path.join(__dirname, '..', '.env.local');
  if (!fs.existsSync(envPath)) {
    const envContent = `# Auto-generated project configuration
NEXT_PUBLIC_PROJECT_NAME=${config.projectName}
NEXT_PUBLIC_PROJECT_OWNER=${config.projectOwner}
NEXT_PUBLIC_BASE_PATH=${config.basePath}
`;
    fs.writeFileSync(envPath, envContent);
  }

  console.log('âœ… Project configuration detected:');
  console.log(`   Name: ${config.projectName}`);
  console.log(`   Owner: ${config.projectOwner}`);
  console.log(`   Base Path: ${config.basePath || '/'}`);
  console.log(`   Source: ${config.detectionSource}`);

  return config;
}

// Run if called directly
if (require.main === module) {
  generateConfig();
}

module.exports = { generateConfig, getProjectInfo, parseGitUrl };
