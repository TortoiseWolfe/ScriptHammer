{
  "posts": [
    {
      "id": "post_00b4ddd5",
      "slug": "countdown-timer-tutorial",
      "title": "Build a Countdown Timer Tutorial",
      "content": "\n# From Template to Client: Building Landing Pages That Convert\n\n## The Landing Page Strategy\n\nScriptHammer isn't just a Next.js template—it's your **entry point** to client relationships.\n\n**The Pitch**: \"I'll customize this production-ready template for your domain on GitHub Pages. $321/year. 12 hours of my time annually.\"\n\nThat's **$27/month** for a professional landing page with:\n\n- Theme customization (most brands just pick light/dark, though ScriptHammer includes 32 themes)\n- Progressive Web App (PWA) capabilities (offline support)\n- Contact forms + calendar booking\n- Search Engine Optimization (SEO)-optimized blog\n- Mobile-responsive, accessible\n\n**The Business Model**: 4 hours initial setup + 8 hours quarterly updates = your foot in the door. When they need a Content Management System (CMS), e-commerce, or custom features—you're their trusted webmaster with recurring revenue + upsell pipeline.\n\n## Why Countdown Timers Work\n\nCountdown timers increase conversions by 8-12%. But fake urgency erodes trust. If you say it ends at midnight January 1st, it **must disappear** at midnight January 1st.\n\nLet's build a real countdown timer using **Product Requirements Prompt (PRP) → SpecKit workflow**.\n\n---\n\n# Part 1: The PRP (Product Requirements Prompt)\n\nA Product Requirements Prompt (PRP) focuses on **what users need**, not how to build it. The `/specify` command reads your PRP and searches the codebase to determine technical approach. PRPs have 3 core sections focusing on product requirements:\n\n## 1. Product Requirements\n\n**What**: Countdown banner showing time until January 1st midnight, promoting \"$321/year Custom Setup\", linking to `/schedule`\n\n**Why**: Drive conversions (8-12% boost), demonstrate capability, capture high-intent leads\n\n**Success Criteria**: Accurate to the second, disappears at midnight, tracks dismissals, mobile responsive, accessible, no Server-Side Rendering (SSR) hydration issues\n\n**Out of Scope**: Payment processing, discount codes, email automation, analytics, A/B testing (Minimum Viable Product/MVP)\n\n## 2. Context & Codebase Intelligence\n\n**Reuse Existing**:\n\n- Button component (`@/components/atomic/Button`)\n- Calendar integration (`/schedule` page already exists)\n- Layout file (`src/app/layout.tsx`) - we'll add the banner below the header\n\n**No New Dependencies**: Use native browser Application Programming Interfaces (APIs)\n\n## 3. Implementation Runbook\n\n**SpecKit Workflow** (PRP → Spec → Plan → Tasks → Implement):\n\n> **Note for Readers**: Steps 2-4 require [Claude Code CLI](https://claude.com/claude-code) installed and configured. If you don't have Claude Code, skip directly to step 5 (component generation) and follow the code examples in Part 2.\n\n```bash\n# 1. Create feature branch (run from host machine)\n./scripts/prp-to-feature.sh countdown-timer 016\n\n# 2. Generate SpecKit spec (Claude Code slash command - tell Claude in the CLI)\n/specify New Year's countdown banner with $321/year offer\n\n# 3. Generate implementation plan (Claude Code slash command)\n/plan Use native Date, localStorage, integrate into layout\n\n# 4. Generate task list (Claude Code slash command)\n/tasks Focus on Test-Driven Development (TDD) approach\n\n# 5. Generate component scaffold (run in Docker container - interactive prompts)\ndocker compose exec scripthammer pnpm run generate:component\n# You'll be prompted for:\n#   - Component name: CountdownBanner\n#   - Category: atomic\n#   - Has props? Y\n#   - Include hooks? N\n```\n\n<details>\n<summary><strong>Alternative: CLI Arguments</strong> (for scripting/automation)</summary>\n\n```bash\ndocker compose exec scripthammer pnpm run generate:component -- \\\n  --name CountdownBanner \\\n  --category atomic \\\n  --hasProps true \\\n  --withHooks false\n```\n\nCategories: `subatomic`, `atomic`, `molecular`, `organisms`, `templates`\n\n</details>\n\n**Generated Artifacts** (if using Claude Code): SpecKit creates `spec.md` (Given/When/Then, Functional Requirements/FR-001+, Non-Functional Requirements/NFR-001+), `plan.md` (technical specs), `research.md`, `data-model.md`, `tasks.md`\n\n**Without Claude Code**: Skip to step 5 and follow the code implementation in Part 2. The component generator creates the 5-file pattern scaffold:\n\n```\nCountdownBanner/\n├── index.tsx                             # Barrel export (re-exports component)\n├── CountdownBanner.tsx                   # Main component (implement below)\n├── CountdownBanner.test.tsx              # Unit tests (see test code below)\n├── CountdownBanner.stories.tsx           # Storybook stories (update after implementation)\n└── CountdownBanner.accessibility.test.tsx # A11y tests (update after implementation)\n```\n\nThe `index.tsx` barrel export allows you to import with `import { CountdownBanner } from '@/components/atomic/CountdownBanner'` instead of specifying the full file path.\n\n> **Note for Storybook**: When creating `CountdownBanner.stories.tsx`, use `@storybook/nextjs` for imports in Next.js projects:\n>\n> ```tsx\n> import type { Meta, StoryObj } from '@storybook/nextjs'; // Not @storybook/react\n> ```\n\n---\n\n# Part 2: The Code (From SpecKit to Production)\n\nAfter running the SpecKit workflow, `/plan` generates technical specifications like state management, timer logic, and rendering approach. Now we implement:\n\n**Tests** (`CountdownBanner.test.tsx`):\n\n```tsx\nimport { describe, it, expect, vi, beforeEach } from 'vitest';\nimport { render, screen, fireEvent } from '@testing-library/react';\n\n// Mock Next.js router (required for useRouter hook)\nvi.mock('next/navigation', () => ({\n  useRouter: () => ({\n    push: vi.fn(),\n  }),\n}));\n\nimport { CountdownBanner } from './CountdownBanner';\n\ndescribe('CountdownBanner', () => {\n  beforeEach(() => {\n    localStorage.clear();\n  });\n\n  it('renders countdown timer', () => {\n    const { container } = render(<CountdownBanner />);\n    // Verify countdown class exists (DaisyUI component)\n    expect(container.querySelector('.countdown')).toBeInTheDocument();\n  });\n\n  it('renders promotional content', () => {\n    render(<CountdownBanner />);\n    expect(screen.getByText('$321/year')).toBeInTheDocument();\n    expect(screen.getByText('Book Now')).toBeInTheDocument();\n  });\n\n  it('persists dismissal with timestamp', () => {\n    render(<CountdownBanner />);\n    const dismissButton = screen.getByLabelText(/dismiss/i);\n    fireEvent.click(dismissButton);\n    const dismissedAt = localStorage.getItem('countdown-dismissed');\n    expect(dismissedAt).toBeTruthy();\n    expect(parseInt(dismissedAt!, 10)).toBeGreaterThan(Date.now() - 1000);\n  });\n});\n```\n\n**Component** (`CountdownBanner.tsx` - full code, inline comments explain key concepts):\n\n```tsx\n'use client';\nimport { useState, useEffect } from 'react';\nimport { useRouter } from 'next/navigation';\nimport Button from '@/components/atomic/Button';\n\nconst DISMISS_KEY = 'countdown-dismissed';\nconst DISMISS_DURATION = 24 * 60 * 60 * 1000; // 24 hours in milliseconds\n\nexport const CountdownBanner = () => {\n  const router = useRouter();\n  const [mounted, setMounted] = useState(false); // Avoid SSR hydration mismatch\n  const [isDismissed, setIsDismissed] = useState(false);\n  const [timeLeft, setTimeLeft] = useState({\n    days: 0,\n    hours: 0,\n    minutes: 0,\n    seconds: 0,\n    isExpired: false,\n  });\n\n  // Check dismissal on mount\n  useEffect(() => {\n    setMounted(true);\n    try {\n      const dismissedAt = localStorage.getItem(DISMISS_KEY);\n      if (dismissedAt) {\n        const timeSinceDismissal = Date.now() - parseInt(dismissedAt, 10);\n        setIsDismissed(timeSinceDismissal < DISMISS_DURATION);\n      }\n    } catch (e) {\n      // Safari private mode - user will see banner every time\n      setIsDismissed(false);\n    }\n  }, []);\n\n  // Calculate and update countdown\n  useEffect(() => {\n    if (!mounted || isDismissed) return;\n\n    const calculateTimeLeft = () => {\n      const targetDate = new Date(new Date().getFullYear() + 1, 0, 1); // Jan 1 local time\n      const difference = targetDate.getTime() - new Date().getTime();\n\n      if (difference <= 0) {\n        return { days: 0, hours: 0, minutes: 0, seconds: 0, isExpired: true };\n      }\n\n      return {\n        days: Math.floor(difference / (1000 * 60 * 60 * 24)),\n        hours: Math.floor((difference / (1000 * 60 * 60)) % 24), // Modulo extracts remainder\n        minutes: Math.floor((difference / 1000 / 60) % 60),\n        seconds: Math.floor((difference / 1000) % 60),\n        isExpired: false,\n      };\n    };\n\n    setTimeLeft(calculateTimeLeft());\n    const timer = setInterval(() => setTimeLeft(calculateTimeLeft()), 1000);\n    return () => clearInterval(timer); // Cleanup prevents memory leaks\n  }, [mounted, isDismissed]);\n\n  if (!mounted || isDismissed || timeLeft.isExpired) return null;\n\n  return (\n    <div\n      className=\"bg-warning text-warning-content fixed top-20 right-6 z-50 max-w-sm rounded-lg p-4 shadow-2xl max-sm:top-16 max-sm:right-4 max-sm:left-4 max-sm:max-w-full\"\n      role=\"banner\"\n      aria-live=\"polite\"\n    >\n      <div className=\"flex flex-col gap-3\">\n        <div className=\"flex items-center gap-2\">\n          <span className=\"text-2xl\">⏰</span>\n          <div>\n            <span className=\"font-bold\">New Year Special</span>\n            <div className=\"font-mono text-lg\">\n              {timeLeft.days}d {timeLeft.hours}h {timeLeft.minutes}m {timeLeft.seconds}s\n            </div>\n          </div>\n        </div>\n\n        <div className=\"flex items-center gap-3\">\n          <div className=\"text-center\">\n            <div className=\"text-2xl font-bold\">$321/year</div>\n            <div className=\"text-sm\">Custom ScriptHammer Setup</div>\n          </div>\n          <Button variant=\"accent\" onClick={() => router.push('/schedule')}>\n            Book Now\n          </Button>\n        </div>\n\n        <button\n          className=\"btn btn-sm btn-circle btn-ghost absolute top-2 right-2\"\n          onClick={() => {\n            try {\n              localStorage.setItem(DISMISS_KEY, Date.now().toString());\n              setIsDismissed(true);\n            } catch (e) {\n              // Safari private mode - just hide for session\n              setIsDismissed(true);\n            }\n          }}\n          aria-label=\"Dismiss countdown banner\"\n        >\n          ✕\n        </button>\n      </div>\n    </div>\n  );\n};\n```\n\n**Integration** (`src/app/layout.tsx`):\n\n```tsx\nimport { CountdownBanner } from '@/components/atomic/CountdownBanner';\nimport { GlobalNav } from '@/components/GlobalNav';\nimport { Footer } from '@/components/Footer';\n\nexport default function RootLayout({ children }) {\n  return (\n    <html>\n      <body>\n        <GlobalNav />\n        <CountdownBanner /> {/* Appears on all pages */}\n        <main>{children}</main>\n        <Footer />\n      </body>\n    </html>\n  );\n}\n```\n\n**Validation**:\n\n```bash\n# Format code to match project style\ndocker compose exec scripthammer pnpm run format\n\n# Run full test suite and build\ndocker compose exec scripthammer sh -c \"pnpm run test:suite && pnpm run build\"\n```\n\n---\n\n# Part 3: Validation & Next Steps\n\n**Validation**: Test-Driven Development (TDD) (tests first), 5-file pattern, mobile tested, accessibility verified, cross-browser, Lighthouse check\n\n**Key Technical Considerations** (from `/plan`):\n\n- **Timezone**: Use `new Date(year + 1, 0, 1)` (local) not UTC string\n- **SSR Mismatch**: Don't render until `mounted` (see code)\n- **Memory Leak**: Return `() => clearInterval(timer)` in useEffect\n- **localStorage**: Wrap in try/catch for Safari private mode\n\n**References**: PRP Methodology (`docs/prp-docs/`), SpecKit Guide, Component Generator, DaisyUI Countdown, React docs, MDN (localStorage, ARIA)\n\n---\n\n# What You've Learned\n\n**Technical**: React hooks, TypeScript, TDD, responsive design, Web Application Programming Interfaces (APIs) (localStorage, Date, setInterval)\n\n**Process**: PRP methodology, SpecKit workflow (/specify → /plan → /tasks → /implement), 5-file component pattern\n\n**Business**: $321/year landing page service, conversion optimization, sales funnel, recurring revenue\n\n## Next Steps\n\n**Customize**: Edit price, CTA text, target date in code\n\n**Test**: `docker compose exec scripthammer sh -c \"pnpm run test:suite && pnpm run build\"`\n\n**Deploy**: `git add . && git commit -m \"feat: Countdown banner\" && git push` (GitHub Actions auto-deploys)\n\n**Track**: Add Google Analytics events, monitor click-through rate, A/B test CTA variations\n\n**Iterate**: Test different CTA text, add social proof, consider exit-intent popup\n\n---\n\n## The Bigger Picture\n\nThis tutorial demonstrates **building a consulting business** using ScriptHammer:\n\n**Your Stack**: Template + Blog + Storybook + Calendar + Contact Form = Portfolio\n\n**Your Process**: PRP → SpecKit = Documented, repeatable, quality-assured workflow\n\n**Your Offer**: $321/year entry point → Value ladder → Recurring revenue\n\nClients want proven solutions. Developers want starting points. Consultants want leverage. ScriptHammer gives you all three.\n\n---\n\n## Ready to Start?\n\n✅ Production-ready countdown component\n✅ Repeatable PRP/SpecKit workflow\n✅ Business model for consulting\n✅ Template to showcase capabilities\n\n**Next Move**: [Fork ScriptHammer](https://github.com/TortoiseWolfe/ScriptHammer/fork) → Deploy countdown → Share on LinkedIn → Book first client\n\n---\n\n_This tutorial was written using the PRP/SpecKit methodology it teaches._\n",
      "excerpt": "Learn the PRP/SpecKit workflow by building a countdown timer. From requirements to production code with ScriptHammer template.",
      "publishedAt": "2025-09-30T00:00:00.000Z",
      "updatedAt": "2025-09-30T20:04:40.884Z",
      "status": "published",
      "author": {
        "id": "default",
        "name": "TortoiseWolfe"
      },
      "metadata": {
        "tags": [
          "tutorial",
          "prp-workflow",
          "react",
          "typescript",
          "component-development",
          "conversion-optimization",
          "business-strategy"
        ],
        "categories": [
          "tutorial",
          "business"
        ],
        "readingTime": 8,
        "wordCount": 1588,
        "showToc": true,
        "showAuthor": true,
        "showShareButtons": true,
        "featured": false,
        "featuredImage": "/blog-images/countdown-timer-tutorial/countdown-banner-preview.svg",
        "featuredImageAlt": "Countdown timer component showing days, hours, minutes, seconds with New Year sale promotion"
      },
      "seo": {
        "title": "Build a Countdown Timer Tutorial",
        "description": "Learn the PRP/SpecKit workflow by building a countdown timer. From requirements to production code with ScriptHammer template.",
        "keywords": [
          "tutorial",
          "prp-workflow",
          "react",
          "typescript",
          "component-development",
          "conversion-optimization",
          "business-strategy"
        ],
        "ogTitle": "Build a Countdown Timer - PRP/SpecKit Tutorial",
        "ogDescription": "Learn the PRP/SpecKit workflow by building a countdown timer. From requirements to production code.",
        "ogImage": "/blog-images/countdown-timer-tutorial/countdown-banner-og.svg",
        "twitterCard": "summary_large_image"
      },
      "frontMatter": {
        "title": "Build a Countdown Timer Tutorial",
        "author": "TortoiseWolfe",
        "date": "2025-09-30T00:00:00.000Z",
        "slug": "countdown-timer-tutorial",
        "tags": [
          "tutorial",
          "prp-workflow",
          "react",
          "typescript",
          "component-development",
          "conversion-optimization",
          "business-strategy"
        ],
        "categories": [
          "tutorial",
          "business"
        ],
        "excerpt": "Learn the PRP/SpecKit workflow by building a countdown timer. From requirements to production code with ScriptHammer template.",
        "featuredImage": "/blog-images/countdown-timer-tutorial/countdown-banner-preview.svg",
        "featuredImageAlt": "Countdown timer component showing days, hours, minutes, seconds with New Year sale promotion",
        "ogImage": "/blog-images/countdown-timer-tutorial/countdown-banner-og.svg",
        "ogTitle": "Build a Countdown Timer - PRP/SpecKit Tutorial",
        "ogDescription": "Learn the PRP/SpecKit workflow by building a countdown timer. From requirements to production code.",
        "twitterCard": "summary_large_image"
      }
    },
    {
      "id": "post_dc7e6879",
      "slug": "this-is-an-extremely-long-url-slug-that-should-be-much-shorter-for-better-seo",
      "title": "low seo",
      "content": "\nThis is a blog post about something that I wanted to write about but I'm not going to include any structure or optimization whatsoever because this is meant to be a bad example that triggers all the SEO warnings in our analyzer system which is designed to help users write better content by identifying common SEO issues that can negatively impact search engine rankings and user engagement metrics.\n\nThis entire paragraph is just one long run-on sentence without any breaks or structure which makes it very difficult to read and understand what the main point is supposed to be and there are no headings or subheadings to break up the content into digestible sections.\n\nThere are no images to make the content more visually appealing and engaging for readers who might otherwise get bored reading a wall of text like this one that just goes on and on without any clear purpose or direction.\n\nThe content is also very short overall and doesn't provide enough information to be valuable to readers or search engines that are looking for comprehensive authoritative content on a topic and there are no keywords or tags defined to help search engines understand what this content is about and there's no meta description that would appear in search results to entice users to click through to read the full article and without any links to other resources or related content this post exists in isolation without contributing to or benefiting from the broader link structure of the website.\n",
      "excerpt": "This is a blog post",
      "publishedAt": "2025-09-28T00:00:00.000Z",
      "updatedAt": "2025-09-30T16:09:48.754Z",
      "status": "published",
      "author": {
        "id": "default",
        "name": "Anonymous"
      },
      "metadata": {
        "tags": [
          "seo",
          "optimization",
          "content-writing",
          "best-practices",
          "web-development"
        ],
        "categories": [],
        "readingTime": 2,
        "wordCount": 252,
        "showToc": true,
        "showAuthor": true,
        "showShareButtons": true,
        "featured": false
      },
      "seo": {
        "title": "low seo",
        "description": "This is a blog post",
        "keywords": [
          "seo",
          "optimization",
          "content-writing",
          "best-practices",
          "web-development"
        ],
        "ogTitle": "low seo",
        "ogDescription": "This is a blog post",
        "ogImage": "/blog-images/bad-seo-example-og.png",
        "twitterCard": "summary"
      },
      "frontMatter": {
        "title": "low seo",
        "author": "Anonymous",
        "date": "2025-09-28T00:00:00.000Z",
        "slug": "this-is-an-extremely-long-url-slug-that-should-be-much-shorter-for-better-seo",
        "excerpt": "This is a blog post",
        "ogImage": "/blog-images/bad-seo-example-og.png",
        "tags": [
          "seo",
          "optimization",
          "content-writing",
          "best-practices",
          "web-development"
        ]
      }
    },
    {
      "id": "post_e9e18581",
      "slug": "auto-configuration-system",
      "title": "Auto-Configuration: Use Template and Start Building",
      "content": "\n# Auto-Configuration: Use Template and Start Building\n\nScriptHammer automatically configures itself based on your new repository. Use this template, and everything adapts to your project name and settings with minimal setup.\n\n## Prerequisites\n\n- **Docker and Docker Compose installed (MANDATORY)**\n- Git configured with a remote repository\n- Basic familiarity with terminal commands\n\n**⚠️ IMPORTANT**: This project REQUIRES Docker. Local npm/pnpm commands are NOT supported. All development MUST use Docker containers.\n\n## Quick Start (10-15 minutes first time)\n\n### 1. Use Template on GitHub\n\nClick \"Use this template\" on [ScriptHammer](https://github.com/TortoiseWolfe/ScriptHammer) and create your repository with any name you like.\n\n### 2. Clone Your New Repository\n\n```bash\ngit clone https://github.com/YourUsername/your-new-repo.git\ncd your-new-repo\n```\n\n### 3. Create and Configure .env File\n\n**IMPORTANT**: This step is required for Docker to run with proper permissions.\n\nFirst, check your User ID and Group ID:\n\n```bash\nid -u  # Shows your UID (often 1000)\nid -g  # Shows your GID (often 1000)\n```\n\nThen create your .env file:\n\n```bash\n# Copy the example file (contains all available options)\ncp .env.example .env\n```\n\nNow **EDIT the .env file** to add your configuration:\n\n```bash\n# Required for Docker - check your actual values:\n# Run: id -u  (to get your UID)\n# Run: id -g  (to get your GID)\nUID=1000  # Replace if your 'id -u' shows different\nGID=1000  # Replace if your 'id -g' shows different\n\n# Optional - Add your service credentials:\nNEXT_PUBLIC_GA_MEASUREMENT_ID=G-XXXXXXXXXX        # Google Analytics\nNEXT_PUBLIC_WEB3FORMS_ACCESS_KEY=your-key-here    # Contact form\nNEXT_PUBLIC_EMAILJS_SERVICE_ID=service_xxx        # Email service\nNEXT_PUBLIC_CALENDAR_URL=your-calendly-url        # Scheduling\n\n# Optional - Customize author info:\nNEXT_PUBLIC_AUTHOR_NAME=Your Name\nNEXT_PUBLIC_AUTHOR_GITHUB=yourusername\nNEXT_PUBLIC_AUTHOR_TWITTER=yourhandle\n```\n\n**Note**: All these are OPTIONAL except UID/GID. The app works without them, but features like analytics and contact forms won't function until configured.\n\n### 4. Start Docker (MANDATORY - No Local Development)\n\n```bash\ndocker compose up\n```\n\nNote: First run will take 5-10 minutes to build the Docker image and install dependencies.\n\n**⚠️ DO NOT attempt to run `npm install` or `pnpm install` locally - it WILL NOT WORK.**\n\n### 5. Access Your Project\n\nYour project is now running at `http://localhost:3000` with your repository name automatically detected!\n\nAll commands MUST be run inside Docker:\n\n```bash\n# ❌ WRONG: pnpm run dev\n# ✅ RIGHT: docker compose exec scripthammer pnpm run dev\n```\n\n## What Gets Auto-Configured\n\nWhen you create from template and clone, ScriptHammer automatically detects and configures:\n\n- **Project Name**: From your repository name\n- **Owner Info**: From your GitHub username (not \"Admin\" or generic names)\n- **Author Attribution**: Your actual GitHub username appears everywhere\n- **URLs**: For deployment and links\n- **PWA Settings**: App name and manifest\n- **Build Paths**: For GitHub Pages deployment\n\n### Where to Find Your Configuration\n\nThe auto-config system generates configuration at build time:\n\n1. **TypeScript Config**: `/src/config/project-detected.ts` - Strongly typed for your components\n2. **JSON Config**: `/src/config/project-detected.json` - Raw configuration data\n\nCheck these files after running `docker compose exec scripthammer pnpm run build` - they contain YOUR project's information automatically detected from Git.\n\n## How to Use It\n\nThe configuration is available everywhere in your code:\n\n```typescript\n// In any component\nimport { detectedConfig } from '@/config/project-detected';\n\nexport function Header() {\n  return (\n    <div>\n      <h1>{detectedConfig.projectName}</h1>\n      <a href={detectedConfig.projectUrl}>View on GitHub</a>\n    </div>\n  );\n}\n```\n\n```typescript\n// In API routes\nimport { detectedConfig } from '@/config/project-detected';\n\nexport async function GET() {\n  return Response.json({\n    project: detectedConfig.projectName,\n    owner: detectedConfig.projectOwner,\n  });\n}\n```\n\n## Minimal Manual Setup\n\nTraditional templates require editing multiple files:\n\n- ❌ Update package.json with project name\n- ❌ Change configuration files in multiple locations\n- ❌ Modify deployment scripts\n- ❌ Edit PWA manifests\n- ❌ Update hardcoded references throughout codebase\n\nWith ScriptHammer, the process is dramatically simplified:\n\n- ✅ Use template with any name\n- ✅ Create `.env` file (one-time, 30 seconds)\n- ✅ Most configuration detected automatically from git\n- ⚠️ Some components may still have hardcoded values (being improved)\n\n## Common Tasks (All Require Docker)\n\n### Deploy to GitHub Pages\n\n```bash\n# MUST use Docker - local commands won't work\ndocker compose exec scripthammer pnpm run build\ndocker compose exec scripthammer pnpm run deploy\n# Automatically configured for your repository\n```\n\n### Configure Production Environment Variables\n\n**IMPORTANT**: Your local `.env` file is NOT used in GitHub Actions. You must add your configuration as GitHub Secrets for production features to work.\n\n#### Setting Up GitHub Secrets\n\n1. **Navigate to your repository settings**:\n   - Go to your GitHub repository\n   - Click **Settings** → **Secrets and variables** → **Actions**\n   - Click **New repository secret**\n\n2. **Add your environment variables as secrets**:\n\n   Copy each value from your `.env` file and add it as a GitHub Secret with the SAME name:\n\n   ```bash\n   # All NEXT_PUBLIC_ variables in alphabetical order:\n   NEXT_PUBLIC_AUTHOR_AVATAR           # Avatar image URL\n   NEXT_PUBLIC_AUTHOR_BIO              # Short biography\n   NEXT_PUBLIC_AUTHOR_BLUESKY          # Bluesky handle\n   NEXT_PUBLIC_AUTHOR_EMAIL            # Contact email\n   NEXT_PUBLIC_AUTHOR_GITHUB           # Your GitHub username\n   NEXT_PUBLIC_AUTHOR_LINKEDIN         # Your LinkedIn username\n   NEXT_PUBLIC_AUTHOR_MASTODON         # Mastodon handle (with instance)\n   NEXT_PUBLIC_AUTHOR_NAME             # Your display name\n   NEXT_PUBLIC_AUTHOR_ROLE             # Your professional role/title\n   NEXT_PUBLIC_AUTHOR_TWITCH           # Twitch username\n   NEXT_PUBLIC_AUTHOR_TWITTER          # Your Twitter/X handle\n   NEXT_PUBLIC_AUTHOR_WEBSITE          # Your personal website\n   NEXT_PUBLIC_BASE_PATH               # Override deployment base path\n   NEXT_PUBLIC_BASE_URL                # Base URL for your site\n   NEXT_PUBLIC_CALENDAR_PROVIDER        # 'calendly' or 'calcom'\n   NEXT_PUBLIC_CALENDAR_URL             # Your booking page URL\n   NEXT_PUBLIC_DISQUS_SHORTNAME        # Disqus comments for blog posts\n   NEXT_PUBLIC_EMAILJS_PUBLIC_KEY       # EmailJS public key\n   NEXT_PUBLIC_EMAILJS_SERVICE_ID       # Email service (EmailJS alternative)\n   NEXT_PUBLIC_EMAILJS_TEMPLATE_ID      # Email template ID\n   NEXT_PUBLIC_GA_MEASUREMENT_ID        # Google Analytics tracking\n   NEXT_PUBLIC_GOOGLE_SITE_VERIFICATION # Google Search Console verification\n   NEXT_PUBLIC_PROJECT_NAME            # Override auto-detected project name\n   NEXT_PUBLIC_PROJECT_OWNER           # Override auto-detected owner\n   NEXT_PUBLIC_SITE_TWITTER_HANDLE      # Site-wide Twitter handle for social cards\n   NEXT_PUBLIC_SITE_URL                # Custom domain (if not GitHub Pages)\n   NEXT_PUBLIC_SOCIAL_PLATFORMS        # Comma-separated list of enabled platforms\n   NEXT_PUBLIC_WEB3FORMS_ACCESS_KEY     # Contact form submissions (Web3Forms)\n   ```\n\n3. **How to add a secret**:\n   - **Name**: Enter the exact variable name (e.g., `NEXT_PUBLIC_GA_MEASUREMENT_ID`)\n   - **Value**: Paste your key/value from `.env` (e.g., `G-XXXXXXXXXX`)\n   - Click **Add secret**\n\n4. **Verify secrets are configured**:\n   - After adding, you'll see them listed (values are hidden)\n   - The deploy workflow will automatically use these during build\n   - Check your deployed site to confirm features are working\n\n#### Important Notes\n\n- **No UID/GID needed**: GitHub Actions doesn't need Docker user permissions\n- **Secrets are encrypted**: GitHub encrypts and hides secret values\n- **Build-time injection**: Secrets are injected during `pnpm run build` in CI/CD\n- **Without secrets**: Your site will deploy but features like analytics, forms, and calendars won't function\n\n#### Updating the Deploy Workflow (Optional)\n\nIf you need to use additional environment variables, update `.github/workflows/deploy.yml`:\n\n```yaml\n- name: Build Next.js app\n  run: pnpm run build\n  env:\n    NEXT_PUBLIC_AUTHOR_AVATAR: ${{ secrets.NEXT_PUBLIC_AUTHOR_AVATAR }}\n    NEXT_PUBLIC_AUTHOR_BIO: ${{ secrets.NEXT_PUBLIC_AUTHOR_BIO }}\n    NEXT_PUBLIC_AUTHOR_BLUESKY: ${{ secrets.NEXT_PUBLIC_AUTHOR_BLUESKY }}\n    NEXT_PUBLIC_AUTHOR_EMAIL: ${{ secrets.NEXT_PUBLIC_AUTHOR_EMAIL }}\n    NEXT_PUBLIC_AUTHOR_GITHUB: ${{ secrets.NEXT_PUBLIC_AUTHOR_GITHUB }}\n    NEXT_PUBLIC_AUTHOR_LINKEDIN: ${{ secrets.NEXT_PUBLIC_AUTHOR_LINKEDIN }}\n    NEXT_PUBLIC_AUTHOR_MASTODON: ${{ secrets.NEXT_PUBLIC_AUTHOR_MASTODON }}\n    NEXT_PUBLIC_AUTHOR_NAME: ${{ secrets.NEXT_PUBLIC_AUTHOR_NAME }}\n    NEXT_PUBLIC_AUTHOR_ROLE: ${{ secrets.NEXT_PUBLIC_AUTHOR_ROLE }}\n    NEXT_PUBLIC_AUTHOR_TWITCH: ${{ secrets.NEXT_PUBLIC_AUTHOR_TWITCH }}\n    NEXT_PUBLIC_AUTHOR_TWITTER: ${{ secrets.NEXT_PUBLIC_AUTHOR_TWITTER }}\n    NEXT_PUBLIC_AUTHOR_WEBSITE: ${{ secrets.NEXT_PUBLIC_AUTHOR_WEBSITE }}\n    # ... all other variables in alphabetical order\n```\n\n**Note**: The current workflow doesn't explicitly list env variables, but Next.js automatically reads `NEXT_PUBLIC_*` secrets during build if they're available in the GitHub Actions environment.\n\n### Run Tests Inside Docker\n\n```bash\n# Run the comprehensive test suite (all tests must run in Docker)\ndocker compose exec scripthammer pnpm run test:suite\n```\n\n**⚠️ REMINDER**: Every single command in this project MUST be prefixed with `docker compose exec scripthammer`. There are NO exceptions.\n\n### Check Current Config\n\nLook at `src/config/project-detected.ts` after running the build—it shows your detected settings.\n\n## Key Benefits\n\n- **Quick Setup**: Use template and start coding in 10-15 minutes\n- **Minimal Configuration**: Only `.env` file required, rest auto-detects\n- **Works in Most Environments**: Local Docker, GitHub Actions CI/CD\n- **Reduced Errors**: Fewer manual edits means fewer mistakes\n\n## How It Works\n\nThe core detection script (`scripts/detect-project.js`) runs at build time:\n\n```javascript\nfunction getProjectInfo() {\n  // 1. Check environment variables (highest priority)\n  if (\n    process.env.NEXT_PUBLIC_PROJECT_NAME &&\n    process.env.NEXT_PUBLIC_PROJECT_OWNER\n  ) {\n    return {\n      projectName: process.env.NEXT_PUBLIC_PROJECT_NAME,\n      projectOwner: process.env.NEXT_PUBLIC_PROJECT_OWNER,\n      source: 'env',\n    };\n  }\n\n  // 2. Try git remote detection\n  const gitUrl = getGitRemoteUrl();\n  const gitInfo = parseGitUrl(gitUrl);\n  if (gitInfo) {\n    return {\n      projectName: gitInfo.repo,\n      projectOwner: gitInfo.owner,\n      source: 'git',\n    };\n  }\n\n  // 3. Fall back to defaults\n  return {\n    projectName: 'ScriptHammer',\n    projectOwner: 'TortoiseWolfe',\n    source: 'default',\n  };\n}\n```\n\nThe script (under 180 lines) handles:\n\n- Multiple git remote formats (HTTPS, SSH, various hosts)\n- CI/CD environment detection\n- Safe file writing with atomic operations\n- TypeScript and JSON generation\n\n## Advanced Features\n\n### Environment Detection\n\nCurrently supported:\n\n- **GitHub Actions CI** - Automatically configures for GitHub Pages\n- **Docker Development** - Consistent development environment (REQUIRED)\n- **Environment Variables** - Override auto-detection with custom values\n\n### Development vs Production\n\n```bash\n# Development - Local testing with hot reload at http://localhost:3000\ndocker compose exec scripthammer pnpm run dev\n\n# Production Build - Creates static files for GitHub Pages deployment\ndocker compose exec scripthammer pnpm run build\ndocker compose exec scripthammer pnpm run deploy\n```\n\nThe project auto-detects your configuration from git, so you don't need different settings for different environments.\n\n## Try It Now\n\n1. **Use Template** [ScriptHammer](https://github.com/TortoiseWolfe/ScriptHammer) (30 seconds)\n2. **Clone** your new repository (30 seconds)\n3. **Create .env** with `cp .env.example .env` (30 seconds)\n4. **Run** `docker compose up` (5-10 minutes first build)\n5. **Check** `http://localhost:3000` - your project is ready!\n\n### What You'll See\n\n- Title bar shows YOUR project name\n- Footer links to YOUR GitHub repository\n- PWA installer shows YOUR app name\n- `/status` page displays YOUR project info\n- All configuration files have YOUR details\n\n## Technical Details\n\n### Generated Files\n\nConfiguration files are generated at build time (not committed to git):\n\n- `src/config/project-detected.ts` - TypeScript configuration\n- `src/config/project-detected.json` - JSON for build scripts\n- `public/manifest.json` - PWA manifest with your project name\n- Meta tags and URLs throughout the application\n\n### Git Remote Parsing\n\nSupports multiple formats:\n\n- `https://github.com/user/repo.git`\n- `git@github.com:user/repo.git`\n- `https://gitlab.com/user/repo.git`\n- `git@bitbucket.org:user/repo.git`\n\n### Build Integration\n\n```json\n// package.json\n{\n  \"scripts\": {\n    \"dev\": \"node scripts/detect-project.js && next dev\",\n    \"build\": \"node scripts/detect-project.js && next build\"\n  }\n}\n```\n\n## Visual Overview\n\n![Auto-Configuration Flow Diagram](/blog-images/auto-config/config-flow.svg)\n_The auto-configuration process: Use Template → Clone → Ready in 3 simple steps_\n\nThe magic happens through our detection script that runs at build time, analyzing your git remote to extract project information and automatically generating all configuration files.\n\n## Traditional Setup vs ScriptHammer\n\n![Before and After Comparison](/blog-images/auto-config/before-after.svg)\n_Save 30-60 minutes of manual configuration with every new project_\n\nWhile traditional templates require editing 22+ files and configuration points, ScriptHammer handles everything automatically. No more hunting for hardcoded values or broken references after using the template.\n\n## Troubleshooting\n\n### Common Issues\n\n**Docker permission errors:**\n\n- Make sure your `.env` file contains correct UID/GID values\n- Run `id -u` and `id -g` to get your system values\n- Ensure Docker daemon is running\n\n**Auto-detection not working:**\n\n- Verify you have a git remote: `git remote -v`\n- If no remote, add one: `git remote add origin https://github.com/YourUsername/your-repo.git`\n- The detection reads from git remote origin URL\n\n**Project name not updating:**\n\n- Auto-detection runs at BUILD time, not runtime\n- Run `docker compose exec scripthammer pnpm run build` to regenerate\n- Check `src/config/project-detected.ts` for detected values\n\n**Hardcoded values still showing \"ScriptHammer\":**\n\n- Some components may still have hardcoded values\n- This is a known limitation being addressed\n- Main configuration files ARE auto-detected correctly\n\n## The Bottom Line\n\nScriptHammer significantly reduces setup friction compared to traditional templates. While not completely \"zero-config,\" it automates most configuration through git detection, requiring only minimal setup (creating the `.env` file).\n\n**Minimal configuration. Quick setup. Use template and build.**\n\n---\n\n_P.S. - Check out `/scripts/detect-project.js` to see the complete auto-configuration implementation. It's a pragmatic solution that handles 90% of configuration automatically._\n",
      "excerpt": "ScriptHammer's auto-configuration eliminates setup friction. Use the template, run Docker, and watch your project automatically adapt with zero manual config.",
      "publishedAt": "2025-09-27T00:00:00.000Z",
      "updatedAt": "2025-09-30T15:49:43.174Z",
      "status": "published",
      "author": {
        "id": "default",
        "name": "Development Team"
      },
      "metadata": {
        "tags": [
          "auto-config",
          "automation",
          "developer-experience"
        ],
        "categories": [
          "DevOps",
          "Automation",
          "DX"
        ],
        "readingTime": 10,
        "wordCount": 1919,
        "showToc": true,
        "showAuthor": true,
        "showShareButtons": true,
        "featured": true,
        "featuredImage": "/blog-images/auto-config/featured.svg",
        "featuredImageAlt": "Auto-Configuration System - Zero Config Magic for Your New Project"
      },
      "seo": {
        "title": "Auto-Configuration: Use Template and Start Building",
        "description": "ScriptHammer's auto-configuration eliminates setup friction. Use the template, run Docker, and watch your project automatically adapt with zero manual config.",
        "keywords": [
          "auto-config",
          "automation",
          "developer-experience"
        ],
        "ogTitle": "Auto-Configuration: Use Template and Start Building",
        "ogDescription": "ScriptHammer's auto-configuration eliminates setup friction. Use the template, run Docker, and watch your project automatically adapt with zero manual config.",
        "ogImage": "/blog-images/auto-config/featured-og.png",
        "twitterCard": "summary"
      },
      "frontMatter": {
        "title": "Auto-Configuration: Use Template and Start Building",
        "slug": "auto-configuration-system",
        "excerpt": "ScriptHammer's auto-configuration eliminates setup friction. Use the template, run Docker, and watch your project automatically adapt with zero manual config.",
        "author": "Development Team",
        "date": "2025-09-27T00:00:00.000Z",
        "status": "scheduled",
        "featured": true,
        "categories": [
          "DevOps",
          "Automation",
          "DX"
        ],
        "tags": [
          "auto-config",
          "automation",
          "developer-experience"
        ],
        "readTime": "5 min read",
        "featuredImage": "/blog-images/auto-config/featured.svg",
        "featuredImageAlt": "Auto-Configuration System - Zero Config Magic for Your New Project",
        "ogImage": "/blog-images/auto-config/featured-og.png"
      }
    },
    {
      "id": "post_361b14b9",
      "slug": "scripthammer-intro",
      "title": "Scripthammer - Opinionated Next.js PWA Template",
      "content": "\n# Scripthammer: Your Production-Ready Next.js Template\n\nScripthammer is an opinionated Next.js template that comes batteries-included with everything you need to build modern web applications. No more setup fatigue - just clone and start building.\n\n## What's Actually In This Template\n\n![Scripthammer Dashboard](/blog-images/scripthammer-intro/dashboard-overview.svg)\n_The Scripthammer dashboard showing the theme switcher and component structure_\n\n### Core Technologies\n\n- **[Next.js](https://nextjs.org/) 15.5.2** with App Router and static export support\n- **[React](https://react.dev/) 19.1.0** with [TypeScript](https://www.typescriptlang.org/) strict mode\n- **[Tailwind CSS](https://tailwindcss.com/) (Cascading Style Sheets) v4** with [DaisyUI](https://daisyui.com/) providing 32 built-in themes\n- **PWA Support** with offline capabilities via [Workbox](https://developer.chrome.com/docs/workbox/)\n- **[Docker](https://www.docker.com/)-First Development** - everything runs in containers\n\n### Real Features That Work\n\n#### 🎨 32 Theme System\n\nNot just light and dark mode - we ship with 32 complete themes from [DaisyUI](https://daisyui.com/):\n\n- Classic: light, dark, cupcake, bumblebee\n- Modern: synthwave, cyberpunk, valentine, halloween\n- Professional: corporate, business, emerald, forest\n- Experimental: acid, lemonade, coffee, winter\n\nTheme switching is instant and persisted across sessions.\n\n#### ♿ Accessibility Built-In\n\n- Color vision assistance for 8 types of color blindness\n- Font size scaling system\n- Screen reader optimizations\n- Keyboard navigation throughout\n- WCAG (Web Content Accessibility Guidelines) 2.1 AA compliance ready\n\n#### 🧪 Testing That Actually Runs\n\n![Testing Suite Output](/blog-images/scripthammer-intro/testing-output.svg)\n_Comprehensive test suite with unit, E2E (End-to-End), and accessibility testing_\n\n```bash\ndocker compose exec scripthammer pnpm run test:suite\n```\n\n- [Vitest](https://vitest.dev/) for unit tests (58% coverage)\n- [Playwright](https://playwright.dev/) for E2E (End-to-End) testing (40+ tests)\n- [Pa11y](https://pa11y.org/) for accessibility testing\n- Component structure validation\n- Pre-push hooks with [Husky](https://typicode.github.io/husky/)\n\n#### 📱 True PWA Support\n\n- Service worker with offline mode\n- Background sync for form submissions\n- [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API) for local data storage\n- App manifest for installability\n- Push notification ready\n\n## Docker Development Environment (MANDATORY)\n\n![Docker Architecture](/blog-images/scripthammer-intro/docker-architecture.svg)\n_Docker-first development environment with isolated containers_\n\n**⚠️ CRITICAL**: ScriptHammer is Docker-only. Local npm/pnpm commands are NOT supported and WILL NOT WORK.\n\nEverything MUST run in [Docker](https://www.docker.com/). No \"works on my machine\" problems:\n\n```bash\n# Start development (REQUIRED - no local alternative)\ndocker compose up\n\n# ALL commands must use docker compose exec:\ndocker compose exec scripthammer pnpm run dev\ndocker compose exec scripthammer pnpm test\ndocker compose exec scripthammer pnpm run generate:component\n\n# ❌ NEVER run locally:\n# pnpm install  # WILL NOT WORK\n# npm run dev   # WILL NOT WORK\n```\n\n## Component Generator\n\nStop copying component boilerplate. Use the generator:\n\n```bash\ndocker compose exec scripthammer pnpm run generate:component MyComponent atomic\n```\n\nThis creates the required 5-file structure:\n\n- `MyComponent.tsx` - Main component\n- `MyComponent.test.tsx` - Unit tests\n- `MyComponent.stories.tsx` - [Storybook](https://storybook.js.org/) stories\n- `MyComponent.accessibility.test.tsx` - A11y tests\n- `index.tsx` - Barrel export\n\n## Project Configuration\n\nThe project auto-detects most configuration from your Git repository:\n\n```typescript\n// Auto-configured from git remote at build time\nconst projectConfig = {\n  name: 'YourRepoName', // Detected from repository\n  owner: 'YourGitHubUsername',\n  basePath: '/', // Configured for GitHub Pages\n  repository: 'https://github.com/YourUsername/YourRepoName',\n};\n```\n\nMinimal setup required - just create your `.env` file and the rest is detected automatically.\n\n## Current Features in Production\n\n### Privacy & Consent\n\n- GDPR (General Data Protection Regulation)-compliant cookie consent system\n- Granular privacy controls\n- [Google Analytics](https://analytics.google.com/) integration (with consent)\n\n### Blog System\n\n- Markdown-based blog with frontmatter\n- SEO (Search Engine Optimization) analysis and scoring\n- Table of contents generation\n- Offline-first with IndexedDB storage\n- Background sync for offline edits\n\n### Maps & Location\n\n- [Leaflet](https://leafletjs.com/) integration for interactive maps\n- Geolocation with privacy consent\n- [OpenStreetMap](https://www.openstreetmap.org/) tiles (no API (Application Programming Interface) key needed)\n\n### Calendar Integration\n\n- [Calendly](https://calendly.com/) and [Cal.com](https://cal.com/) embedded support\n- Privacy-first with consent modal\n- Event scheduling capabilities\n\n## File Structure\n\n```\nsrc/\n├── app/                # Next.js app router pages\n├── components/\n│   ├── subatomic/     # Smallest reusable pieces\n│   ├── atomic/        # Basic components\n│   ├── molecular/     # Composite components\n│   └── organisms/     # Full sections\n├── contexts/          # React contexts\n├── services/          # Business logic\n├── lib/              # Core libraries\n├── utils/            # Utility functions\n└── types/            # TypeScript definitions\n```\n\n## Testing Commands\n\n```bash\n# Quick validation\ndocker compose exec scripthammer pnpm run test:quick\n\n# Full test suite\ndocker compose exec scripthammer pnpm run test:suite\n\n# Specific tests\ndocker compose exec scripthammer pnpm run type-check\ndocker compose exec scripthammer pnpm run lint\ndocker compose exec scripthammer pnpm run test:coverage\n```\n\n## Why Scripthammer?\n\n1. **Quick Setup** - Create `.env`, run `docker compose up`, and you're developing\n2. **Reduced Configuration** - Opinionated choices with auto-detection from git\n3. **Production Features** - Battle-tested components and patterns\n4. **TypeScript First** - Comprehensive typing with strict mode enabled\n5. **Well Tested** - Full test suite with unit, E2E, and accessibility testing\n\n## Getting Started (Docker Required)\n\n**⚠️ PREREQUISITE**: Docker and Docker Compose MUST be installed. This project does NOT support local development.\n\n```bash\n# Use the template on GitHub first\n# Then clone YOUR new repository\ngit clone https://github.com/YourUsername/your-new-repo.git\ncd your-new-repo\n\n# Create required .env file (MANDATORY)\ncp .env.example .env\n\n# Start Docker (ONLY way to run this project)\ndocker compose up  # First build takes 5-10 minutes\n\n# Open http://localhost:3000\n```\n\n**Remember**:\n\n- ✅ `docker compose exec scripthammer pnpm install` - Correct\n- ❌ `pnpm install` - Will NOT work\n- ❌ `npm install` - Will NOT work\n\n## What's Next?\n\nCheck out the [CONSTITUTION.md](https://github.com/TortoiseWolfe/ScriptHammer/blob/main/.specify/memory/constitution.md) for the project principles and current sprint goals. Read [CLAUDE.md](https://github.com/TortoiseWolfe/ScriptHammer/blob/main/CLAUDE.md) for AI (Artificial Intelligence) pair programming guidelines and best practices when working with this codebase.\n\nThis is Scripthammer. Stop configuring, start shipping.\n",
      "excerpt": "Opinionated Next.js 15.5 template with PWA support, 32 DaisyUI themes, Docker-first development environment, and comprehensive testing suite.",
      "publishedAt": "2025-09-26T00:00:00.000Z",
      "updatedAt": "2025-09-29T18:22:24.499Z",
      "status": "published",
      "author": {
        "id": "default",
        "name": "TortoiseWolfe"
      },
      "metadata": {
        "tags": [
          "scripthammer",
          "next.js",
          "pwa",
          "typescript",
          "docker"
        ],
        "categories": [
          "documentation"
        ],
        "readingTime": 5,
        "wordCount": 907,
        "showToc": true,
        "showAuthor": true,
        "showShareButtons": true,
        "featured": false,
        "featuredImage": "/blog-images/scripthammer-intro/featured-og.svg",
        "featuredImageAlt": "Scripthammer - The Opinionated Next.js PWA Template with 32 themes and Docker development"
      },
      "seo": {
        "title": "Scripthammer - Opinionated Next.js PWA Template",
        "description": "Opinionated Next.js 15.5 template with PWA support, 32 DaisyUI themes, Docker-first development environment, and comprehensive testing suite.",
        "keywords": [
          "scripthammer",
          "next.js",
          "pwa",
          "typescript",
          "docker"
        ],
        "ogTitle": "Scripthammer - Opinionated Next.js PWA Template",
        "ogDescription": "Build production-ready Next.js apps with 32 themes, Docker development, PWA support, and comprehensive testing. No configuration hell.",
        "ogImage": "/blog-images/scripthammer-intro/featured-og.png",
        "twitterCard": "summary_large_image"
      },
      "frontMatter": {
        "title": "Scripthammer - Opinionated Next.js PWA Template",
        "author": "TortoiseWolfe",
        "date": "2025-09-26T00:00:00.000Z",
        "slug": "scripthammer-intro",
        "tags": [
          "scripthammer",
          "next.js",
          "pwa",
          "typescript",
          "docker"
        ],
        "categories": [
          "documentation"
        ],
        "excerpt": "Opinionated Next.js 15.5 template with PWA support, 32 DaisyUI themes, Docker-first development environment, and comprehensive testing suite.",
        "featuredImage": "/blog-images/scripthammer-intro/featured-og.svg",
        "featuredImageAlt": "Scripthammer - The Opinionated Next.js PWA Template with 32 themes and Docker development",
        "ogImage": "/blog-images/scripthammer-intro/featured-og.png",
        "ogTitle": "Scripthammer - Opinionated Next.js PWA Template",
        "ogDescription": "Build production-ready Next.js apps with 32 themes, Docker development, PWA support, and comprehensive testing. No configuration hell.",
        "twitterCard": "summary_large_image"
      }
    }
  ],
  "generated": "2025-09-30T20:04:51.156Z",
  "count": 4,
  "tags": [
    "tutorial",
    "prp-workflow",
    "react",
    "typescript",
    "component-development",
    "conversion-optimization",
    "business-strategy",
    "seo",
    "optimization",
    "content-writing",
    "best-practices",
    "web-development",
    "auto-config",
    "automation",
    "developer-experience",
    "scripthammer",
    "next.js",
    "pwa",
    "docker"
  ],
  "categories": [
    "tutorial",
    "business",
    "DevOps",
    "Automation",
    "DX",
    "documentation"
  ]
}