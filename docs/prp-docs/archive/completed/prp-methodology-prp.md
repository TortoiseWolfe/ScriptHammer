# Product Requirements Prompt (PRP)

**Feature Name**: PRP Methodology & SpecKit Integration
**Priority**: P3 (Documentation & Process)
**Sprint**: Post-Sprint 3.5
**Status**: ðŸ“¥ Inbox
**Created**: 2025-09-30
**Author**: ScriptHammer Development Team

---

## 1. Product Requirements

### What We're Building

A comprehensive methodology that bridges product thinking (PRPs) with implementation execution (SpecKit workflow). This documents how to convert high-level product requirements into actionable, tested code using the `/specify`, `/plan`, `/tasks`, and `/implement` commands.

### Why We're Building It

- **Proven Process**: 12 PRPs successfully completed (002-014) but methodology undocumented
- **SpecKit Integration**: PRPs written before SpecKit was fully integrated
- **Repeatability**: PRP-012 (Visual Regression) and future features need clear process
- **Template Value**: Users forking ScriptHammer need to understand the development workflow
- **Knowledge Transfer**: Capture lessons learned while they're fresh

### Success Criteria

- [ ] Clear documentation of what PRPs are and when to use them
- [ ] Step-by-step guide for PRP â†’ SpecKit workflow
- [ ] Real examples from completed PRPs (at least 2-3)
- [ ] Quick reference guide for common scenarios
- [ ] PRP-012 can be executed following this methodology
- [ ] Template users understand how to add features using this process

### Out of Scope

- Implementation details of SpecKit itself (that's upstream)
- Alternative methodologies (Shape Up, Scrum, etc.)
- Project management tooling beyond what exists
- AI-assisted code generation (focused on workflow, not AI tools)

---

## 2. Context & Codebase Intelligence

### Existing Patterns to Follow

#### Current PRP Structure

PRPs follow a 7-section format (see `visual-regression-testing-prp.md`):

1. **Product Requirements** - What, Why, Success Criteria, Out of Scope
2. **Context & Codebase Intelligence** - Existing patterns, dependencies, file structure
3. **Technical Specifications** - Implementation details (examples)
4. **Implementation Runbook** - Step-by-step execution
5. **Validation Loops** - Quality checks
6. **Risk Mitigation** - Potential issues and solutions
7. **References** - Internal and external documentation

#### SpecKit Commands Available

```bash
# Located in .claude/commands/
/specify   # Create feature spec from natural language
/plan      # Generate implementation plan with design artifacts
/tasks     # Break down into actionable, dependency-ordered tasks
/implement # Execute the task list (TDD approach)
/clarify   # Identify underspecified areas
/analyze   # Cross-artifact consistency check
```

#### PRP-to-Feature Script

```bash
# scripts/prp-to-feature.sh
./scripts/prp-to-feature.sh <prp-name> <branch-number>

# Example:
./scripts/prp-to-feature.sh visual-regression 012
```

Creates:

- Feature branch `012-visual-regression`
- Copies PRP to `specs/012-visual-regression/spec.md`
- Updates PRP-STATUS.md to "In Progress"

### Dependencies & Existing Infrastructure

#### PRP Documentation

```
docs/prp-docs/
â”œâ”€â”€ PRP-STATUS.md              # Dashboard of all PRPs
â”œâ”€â”€ PRP-WORKFLOW.md            # Original sequential workflow
â”œâ”€â”€ SPEC.md                    # Original PRP specification
â”œâ”€â”€ visual-regression-testing-prp.md  # Example PRP
â””â”€â”€ *-prp.md                   # Individual PRPs
```

#### SpecKit Templates

```
.specify/
â”œâ”€â”€ templates/
â”‚   â”œâ”€â”€ spec-template.md       # Feature specification template
â”‚   â”œâ”€â”€ plan-template.md       # Implementation plan template
â”‚   â””â”€â”€ tasks-template.md      # Task breakdown template
â”œâ”€â”€ scripts/bash/
â”‚   â”œâ”€â”€ create-new-feature.sh  # Initialize feature branch
â”‚   â”œâ”€â”€ setup-plan.sh          # Prepare planning phase
â”‚   â””â”€â”€ check-task-prerequisites.sh  # Validate before tasks
â””â”€â”€ memory/
    â””â”€â”€ constitution.md        # Project principles
```

### File Structure

```
ScriptHammer/
â”œâ”€â”€ docs/prp-docs/
â”‚   â”œâ”€â”€ prp-methodology-prp.md       # NEW: This PRP
â”‚   â”œâ”€â”€ SPECKIT-PRP-GUIDE.md         # NEW: Quick reference
â”‚   â””â”€â”€ PRP-WORKFLOW.md              # UPDATE: Add SpecKit section
â”œâ”€â”€ specs/
â”‚   â””â”€â”€ 001-prp-methodology/         # NEW: Generated by SpecKit
â”‚       â”œâ”€â”€ spec.md                  # Generated by /specify
â”‚       â”œâ”€â”€ plan.md                  # Generated by /plan
â”‚       â”œâ”€â”€ tasks.md                 # Generated by /tasks
â”‚       â””â”€â”€ research.md              # Generated by /plan
â””â”€â”€ .claude/commands/                # Existing SpecKit commands
```

---

## 3. Technical Specifications

### The PRP/SpecKit Workflow

#### Phase 1: Product Requirements (PRP Creation)

**Purpose**: Define WHAT and WHY from a product perspective

**Process**:

1. Identify user need or business requirement
2. Write PRP document following 7-section structure
3. Focus on product thinking (avoid implementation details)
4. Include success criteria and acceptance tests
5. Save to `docs/prp-docs/<feature-name>-prp.md`

**Output**: PRP document ready for conversion

#### Phase 2: Feature Branch Setup

```bash
# Run the conversion script
./scripts/prp-to-feature.sh <prp-name> <branch-number>

# Example:
./scripts/prp-to-feature.sh prp-methodology 001
```

**What it does**:

- Creates and checks out branch `001-prp-methodology`
- Copies PRP to `specs/001-prp-methodology/spec.md`
- Updates PRP-STATUS.md to "In Progress"

**Output**: Feature branch ready, initial spec.md created

#### Phase 3: Specification (/specify)

**Purpose**: Convert PRP into SpecKit-compatible specification

**Command**:

```bash
/specify [feature description]
```

Or if PRP already copied:

```bash
/specify # Uses existing spec.md content
```

**What it does**:

- Runs `.specify/scripts/bash/create-new-feature.sh`
- Loads `.specify/templates/spec-template.md`
- Generates `specs/<branch>/spec.md` following template structure
- Marks ambiguities with `[NEEDS CLARIFICATION: ...]`

**Key Sections Generated**:

- User Scenarios & Testing (Given/When/Then)
- Functional Requirements (FR-001, FR-002, ...)
- Non-Functional Requirements (NFR-001, ...)
- Key Entities (if data involved)
- Success Metrics
- Risks & Assumptions

**Output**: Complete feature specification ready for planning

#### Phase 4: Planning (/plan)

**Purpose**: Generate implementation plan and design artifacts

**Command**:

```bash
/plan [optional technical context]
```

**What it does**:

- Runs `.specify/scripts/bash/setup-plan.sh`
- Loads `.specify/templates/plan-template.md`
- Reads constitution for project principles
- Executes 9-phase planning workflow

**Generated Artifacts**:

1. **plan.md** - Main implementation plan
   - Architecture overview
   - Tech stack decisions
   - File structure
   - Implementation phases
   - Testing strategy

2. **research.md** - Technical research (Phase 0)
   - Library comparisons
   - Architecture decisions
   - Trade-off analysis

3. **data-model.md** - Entity definitions (Phase 1)
   - Database schemas
   - Data relationships
   - Validation rules

4. **contracts/** - API specifications (Phase 1)
   - OpenAPI/YAML specs
   - Request/response formats
   - Error codes

5. **quickstart.md** - Integration scenarios (Phase 1)
   - User flows
   - Test scenarios
   - Setup instructions

**Output**: Complete implementation plan with design artifacts

#### Phase 5: Task Breakdown (/tasks)

**Purpose**: Convert plan into actionable, dependency-ordered tasks

**Command**:

```bash
/tasks [optional context]
```

**What it does**:

- Runs `.specify/scripts/bash/check-task-prerequisites.sh`
- Analyzes all generated artifacts
- Loads `.specify/templates/tasks-template.md`
- Generates ordered task list

**Task Categories**:

```markdown
## Setup Tasks

- T001: Project initialization
- T002: Install dependencies
- T003: Configure linting

## Test Tasks [P]

- T004: [P] Create contract test for endpoint A
- T005: [P] Create contract test for endpoint B
- T006: Integration test for user flow

## Core Implementation Tasks

- T007: [P] Implement Entity A model
- T008: [P] Implement Entity B model
- T009: Implement Service A (depends on T007)
- T010: Implement Endpoint A (depends on T009)

## Integration Tasks

- T011: Database connection setup
- T012: Middleware integration
- T013: Logging configuration

## Polish Tasks [P]

- T014: [P] Unit tests for Service A
- T015: [P] Performance optimization
- T016: [P] Documentation update
```

**Task Markers**:

- `[P]` = Parallel execution allowed (different files, independent)
- No `[P]` = Sequential (dependencies or shared files)

**Output**: Numbered, dependency-ordered task list ready for execution

#### Phase 6: Implementation (/implement)

**Purpose**: Execute tasks following TDD principles

**Command**:

```bash
/implement
```

**What it does**:

- Runs `.specify/scripts/bash/check-implementation-prerequisites.sh`
- Loads tasks.md and analyzes dependencies
- Executes tasks phase-by-phase
- Follows TDD: tests before implementation
- Marks completed tasks with `[X]`

**Execution Rules**:

1. **Setup First** - Initialize before anything else
2. **Tests Before Code** - TDD approach for all features
3. **Respect Dependencies** - Sequential tasks run in order
4. **Parallel When Possible** - `[P]` tasks can run concurrently
5. **Validate Each Phase** - Ensure phase completion before proceeding

**Output**: Fully implemented feature with tests

### Real-World Example: PRP-010 (EmailJS Integration)

```
docs/prp-docs/emailjs-integration-prp.md
  â†“
./scripts/prp-to-feature.sh emailjs-integration 010
  â†“
Branch: 010-emailjs-integration
specs/010-emailjs-integration/spec.md (PRP copied)
  â†“
/specify
  â†“
specs/010-emailjs-integration/spec.md (SpecKit format)
  - User scenarios (backup email service)
  - FR-001: Must provide failover from Web3Forms
  - FR-002: Must retry failed sends
  - NFR-001: Response time < 3s
  â†“
/plan
  â†“
specs/010-emailjs-integration/
  â”œâ”€â”€ plan.md (EmailJS integration strategy)
  â”œâ”€â”€ research.md (EmailJS vs other providers)
  â”œâ”€â”€ data-model.md (Email queue schema)
  â”œâ”€â”€ contracts/emailjs-api.yaml
  â””â”€â”€ quickstart.md (Testing with mock API)
  â†“
/tasks
  â†“
specs/010-emailjs-integration/tasks.md
  - T001: Install @emailjs/browser
  - T002: [P] Create EmailJS provider contract test
  - T003: [P] Create failover integration test
  - T004: Implement EmailJS service
  - T005: Integrate with existing contact form
  - T006: Add retry logic
  - T007: [P] Unit tests
  â†“
/implement
  â†“
âœ… 100% test coverage, feature complete
```

---

## 4. Implementation Runbook

### Step 1: Write the PRP

**When to create a PRP**:

- New feature request from users
- Constitutional requirement not yet implemented
- Significant refactoring or architecture change
- Integration with external service

**PRP Writing Guidelines**:

```markdown
# 1. Product Requirements

- What: 1-2 sentence description
- Why: Business/user value (3-5 bullet points)
- Success Criteria: Measurable outcomes (checkboxes)
- Out of Scope: Explicitly state what's NOT included

# 2. Context & Codebase Intelligence

- Existing patterns to follow (code examples)
- Dependencies and libraries
- File structure (show where code goes)

# 3. Technical Specifications

- Implementation approach (with code snippets)
- Architecture diagrams if complex
- Configuration examples

# 4. Implementation Runbook

- Step-by-step execution
- Bash commands with examples
- Expected outputs at each step

# 5. Validation Loops

- Pre-implementation checks
- During implementation checks
- Post-implementation verification

# 6. Risk Mitigation

- List potential risks
- Mitigation strategy for each

# 7. References

- Internal docs
- External resources
- Related PRPs
```

**Save to**: `docs/prp-docs/<feature-name>-prp.md`

### Step 2: Run PRP-to-Feature Script

```bash
# From repository root
./scripts/prp-to-feature.sh <prp-name> <number>

# Example:
./scripts/prp-to-feature.sh visual-regression 012

# What happens:
# 1. Creates branch 012-visual-regression
# 2. Copies PRP to specs/012-visual-regression/spec.md
# 3. Updates PRP-STATUS.md
```

**Verify**:

```bash
git branch --show-current  # Should be 012-visual-regression
ls specs/012-visual-regression/  # Should see spec.md
```

### Step 3: Run /specify

**Tell Claude**:

```
/specify Visual regression testing system using Chromatic
```

Or if PRP already detailed enough:

```
/specify # Uses existing spec.md
```

**What to expect**:

- Claude reads `.specify/templates/spec-template.md`
- Converts PRP format â†’ SpecKit spec format
- Generates User Scenarios (Given/When/Then)
- Creates Functional Requirements (FR-001, FR-002, ...)
- Adds Non-Functional Requirements if needed
- Marks ambiguities with [NEEDS CLARIFICATION]

**Review**:

```bash
cat specs/012-visual-regression/spec.md

# Look for:
# - Complete User Scenarios section
# - All Functional Requirements listed
# - No [NEEDS CLARIFICATION] markers (or resolve them)
```

**If clarifications needed**:

```
/clarify  # Asks targeted questions about ambiguities
```

### Step 4: Run /plan

**Tell Claude**:

```
/plan Use Chromatic for Storybook integration, test 4 themes initially
```

**What to expect**:

- Claude reads spec.md, constitution.md
- Executes plan-template.md workflow (9 phases)
- Generates multiple artifacts in `specs/<branch>/`

**Generated files**:

```bash
ls specs/012-visual-regression/

# You should see:
# - plan.md         (main implementation plan)
# - research.md     (library comparisons, decisions)
# - data-model.md   (if data structures needed)
# - contracts/      (API specs if applicable)
# - quickstart.md   (integration scenarios)
```

**Review plan.md**:

```markdown
# Look for:

- Architecture overview
- Tech stack decisions (Chromatic vs Percy)
- File structure (which files to create/modify)
- Implementation phases
- Testing strategy
```

**Iterate if needed**:

```
/plan # Run again with refined context
```

### Step 5: Run /tasks

**Tell Claude**:

```
/tasks Focus on Storybook integration first, defer mobile testing
```

**What to expect**:

- Claude analyzes plan.md, data-model.md, contracts/, quickstart.md
- Loads tasks-template.md
- Generates dependency-ordered task list

**Generated file**:

```bash
cat specs/012-visual-regression/tasks.md

# Structure:
# ## Setup Tasks (T001-T003)
# ## Test Tasks [P] (T004-T007)
# ## Core Implementation (T008-T015)
# ## Integration Tasks (T016-T018)
# ## Polish Tasks [P] (T019-T025)
```

**Key task features**:

- Numbered (T001, T002, ...)
- Ordered by dependencies
- [P] markers for parallel execution
- File paths specified
- Acceptance criteria per task

**Review**:

- Are dependencies correct?
- Can [P] tasks really run in parallel?
- Is TDD approach followed (tests before implementation)?

### Step 6: Run /implement (or Manual Execution)

**Option A: Automated**:

```
/implement
```

Claude executes tasks sequentially, marks completed with [X].

**Option B: Manual** (recommended for complex features):

```bash
# Execute tasks one-by-one
# T001: Install dependencies
pnpm add -D chromatic

# T002: [P] Create contract test
# ... implement test ...

# Mark complete in tasks.md:
# - [X] T001: Install dependencies
# - [X] T002: Create contract test
```

**Follow TDD**:

1. Write test (RED)
2. Implement feature (GREEN)
3. Refactor if needed
4. Mark task complete

**Validation after each phase**:

```bash
pnpm run type-check  # TypeScript validation
pnpm run lint        # ESLint
pnpm test           # Run tests
```

### Step 7: Final Validation

**Before marking PRP complete**:

```bash
# Full test suite
docker compose exec scripthammer pnpm run test:suite

# E2E tests if applicable
pnpm test:e2e

# Accessibility tests
pnpm test:a11y:dev

# Build test
pnpm run build
```

**Update documentation**:

- Update PRP-STATUS.md (mark complete)
- Add completion report (if major feature)
- Update CHANGELOG.md

**Commit and PR**:

```bash
git add .
git commit -m "feat: implement visual regression testing (PRP-012)"
git push origin 012-visual-regression

# Create PR via gh CLI or GitHub UI
```

---

## 5. Validation Loops

### Pre-Implementation Checks

- [x] PRP document written and reviewed
- [x] Feature branch created via prp-to-feature.sh
- [x] PRP-STATUS.md updated to "In Progress"
- [x] spec.md exists in specs/<branch>/
- [ ] All [NEEDS CLARIFICATION] markers resolved
- [ ] plan.md generated with complete phases
- [ ] tasks.md has numbered, ordered task list

### During Implementation

- [ ] Following TDD approach (tests first)
- [ ] Each task has acceptance criteria
- [ ] Type checking passes after each task
- [ ] Lint passes after each task
- [ ] Tests pass after each task
- [ ] Completed tasks marked [X] in tasks.md

### Post-Implementation

- [ ] All tasks completed (100%)
- [ ] Full test suite passes (test:suite)
- [ ] Test coverage maintained or improved
- [ ] Production build succeeds
- [ ] Documentation updated
- [ ] PRP-STATUS.md marked complete
- [ ] CHANGELOG.md updated
- [ ] PR created and merged

---

## 6. Risk Mitigation

### Potential Risks

1. **Risk**: PRP too vague, SpecKit can't generate concrete spec
   **Mitigation**: Use `/clarify` command to identify gaps, iterate on PRP

2. **Risk**: Generated tasks have circular dependencies
   **Mitigation**: Review tasks.md carefully, manually reorder if needed

3. **Risk**: Implementation deviates from plan
   **Mitigation**: Regularly sync with spec.md and plan.md, update if requirements change

4. **Risk**: PRP/SpecKit workflow feels heavyweight for small changes
   **Mitigation**: Use full workflow for features, skip for bug fixes and minor tweaks

5. **Risk**: Confusion between PRP format and SpecKit spec format
   **Mitigation**: This documentation! PRPs are product-focused, SpecKit specs are implementation-focused

### Common Pitfalls

**Pitfall**: Writing implementation details in PRP
**Solution**: PRPs describe WHAT and WHY, not HOW. Implementation goes in plan.md

**Pitfall**: Skipping /specify step, using PRP as spec.md directly
**Solution**: Always run /specify to convert PRP format â†’ SpecKit format

**Pitfall**: Running /plan without running /specify first
**Solution**: Follow the sequence: /specify â†’ /plan â†’ /tasks â†’ /implement

**Pitfall**: Marking tasks complete without tests
**Solution**: TDD is mandatory. Test task + implementation task = both complete

---

## 7. References

### Internal Documentation

- PRP Status Dashboard: `/docs/prp-docs/PRP-STATUS.md`
- PRP Workflow (original): `/docs/prp-docs/PRP-WORKFLOW.md`
- Example PRP: `/docs/prp-docs/visual-regression-testing-prp.md`
- SpecKit Commands: `/.claude/commands/`
- Constitution: `/.specify/memory/constitution.md`

### SpecKit Templates

- Spec Template: `/.specify/templates/spec-template.md`
- Plan Template: `/.specify/templates/plan-template.md`
- Tasks Template: `/.specify/templates/tasks-template.md`

### Completed PRP Examples

- PRP-002: Component Structure
- PRP-010: EmailJS Integration (100% coverage)
- PRP-011: PWA Background Sync
- PRP-013: Calendar Integration
- PRP-014: Geolocation Map

### External Resources

- [SpecKit Documentation](https://docs.specify.dev/) (if available)
- [Atomic Design Methodology](https://atomicdesign.bradfrost.com/)
- [Test-Driven Development (TDD)](https://martinfowler.com/bliki/TestDrivenDevelopment.html)

---

## PRP Workflow Status

### Review Checklist (Inbox â†’ Outbox)

- [ ] PRP methodology clearly documented
- [ ] SpecKit integration explained step-by-step
- [ ] Real examples from completed PRPs included
- [ ] Quick reference guide created
- [ ] No blocking dependencies
- [ ] Approved by: [PENDING]

### Processing Status (Outbox â†’ Processed)

- [ ] Specification generated via /specify
- [ ] Plan created via /plan
- [ ] Tasks broken down via /tasks
- [ ] Implementation started
- [ ] Documentation complete
- [ ] Completed on: [PENDING]

---

<!--
PRP-001: PRP Methodology & SpecKit Integration
Documents how to convert Product Requirements Prompts into
executable features using SpecKit workflow commands.

This PRP will dogfood the process by going through
/specify â†’ /plan â†’ /tasks â†’ /implement itself.
-->
